import React from 'react';
import ReactDOM from 'react-dom';
import Controller from './Controller.jsx';
import PostTypeLocation from './../Location/Post_Type.jsx';

/**
 * Handles the editing screens of post types.
 */
export default class Post_Type extends Controller {
	env = {}

	getLocationClass() {
		return PostTypeLocation;
	}

	/**
	 * Additional to standard controller contructor, adds a listneer to the post form.
	 */
	constructor() {
		super();

		// Add environment (rule) listeners and collect the initial state
		this.initializeEnvironment();

		// Add a submission handler for validation purposes
		document.getElementById( 'post' ).addEventListener( 'submit', this.onSubmit.bind( this ) );
	}

	/**
	 * Saves the location object locally once it has been mounted.
	 *
	 * @param {React.Element> form The form that has just been mounted.
	 * @param {HTMLElement}   root The root element for the location.
	 */
	locationDidMount( form, root ) {
		Controller.prototype.locationDidMount.apply( this, arguments );

		form.associateWithBox( root );
	}

	/**
	 * Checks if the submission of the #post form should be prevented because of validation.
	 *
	 * @param {Event} e The event that just happened.
	 */
	onSubmit( e ) {
		// Collect all errors
		const reducer = ( errors, location ) => errors.concat( location.form.validate() )
		const errors  = this.locations.reduce( reducer, [] )

		if( errors.length ) {

			// Display the errors and prevent the submission if any
			e.preventDefault();
			this.displayErrors( errors );

		} else {

			// Clear existing errors in order not to confuse the user while waiting
			this.clearErrors();

		}
	}

	/**
	 * Displays all errors as a notice in the beginning of the page.
	 *
	 * @param {Array.string} errors All errors, generated by top-level fields.
	 */
	displayErrors( errors ) {
		const notice = this.generateErrorNotice( errors );

		// Cleanup all success messages and existing UF errors.
		const existing = document.querySelectorAll( '.notice-success, .uf-error' );
		Array.from( existing ).forEach( message => message.parentNode.removeChild( message ) );

		// Create React root element in order to allow rendering
		const wrap = document.createElement( 'div' );
		wrap.classList.add( 'uf-errors' );

		// Put the root element in the right place
		const slugBox = document.getElementById( 'edit-slug-box' );
		const after = slugBox || document.getElementById( 'titlediv' );
		after.parentNode.insertBefore( wrap, after.nextSibling );

		ReactDOM.render(
			notice,
			wrap
		);
	}

	/**
	 * Clears all errors, which have already been displayed.
	 */
	clearErrors() {
		const wrap = document.querySelector( '.uf-errors' );

		if( ! wrap ) {
			return;
		}

		ReactDOM.unmountComponentAtNode( wrap );
		wrap.parentNode.removeChild( wrap );
	}

	/**
	 * Adds all necessary listners and loads the initial environment.
	 */
	initializeEnvironment() {
		const update = this.updateEnvironment.bind( this );

		const listen = ( selector, eventName ) => {
			Array.from( document.querySelectorAll( selector ) ).forEach( el => {
				el.addEventListener( eventName, update );
			});
		}

		listen( '#page_template', 'change' );
		listen( '#post-formats-select input', 'change' );
		listen( '#post_status', 'change' );
		listen( '#parent_id', 'change' );
		listen( '.categorychecklist input', 'change' );

		this.updateEnvironment();
	}

	/**
	 * Updates all environmental vars.
	 */
	updateEnvironment() {
		this.env = Object.assign( {}, this.env );

		// Small shortcut
		const all = ( selector, callback ) => {
			Array.from( document.querySelectorAll( selector ) ).forEach( callback );
		}

		// Check templates
		all( '#page_template', select => {
			this.env.templates = select.value;
		});

		// Check formats
		all( '#post-formats-select input', input => {
			if( 'radio' == input.type && input.checked ) {
				this.env.formats = input.value;
			}
		});

		// Check the status of the post
		all( '#post_status', select => {
			this.env.stati = select.value;
		});

		// Check for a post parent
		all( '#parent_id', select => {
			Array.from( select.children ).forEach( option => {
				if( option.value !== select.value ) return;

				const stringLevel = option.className.replace('level-', '');
				if( stringLevel.match( /^\d+$/ ) ) {
					this.env.levels = parseInt( stringLevel ) + 2;
				} else {
					this.env.levels = 1;
				}
			});

			this.env.parents = select.value ? parseInt( select.value ) : false;
		});

		// do terms here

		console.log(this.env);
	}
}
