<?php
namespace Ultimate_Fields;

use Ultimate_Fields\Datastore;
use Ultimate_Fields\Container;
use Ultimate_Fields\Helper\Data_Source;
use Ultimate_Fields\Helper\Groups_Iterator;
use Ultimate_Fields\Helper\Layout_Rows_Iterator;
use Ultimate_Fields\Helper\Layout_Group_Values;
use Ultimate_Fields\Helper\Complex_Values;

/**
 * Drives the data-related functions of Ultimate Fields' data API.
 *
 * This class handles data retrival, processing and looping. It's used from all data functions
 * like get_value(), the_value() and etc., including repeatable data.
 *
 * @since 3.0
 */
class Data_API {
	/**
	 * Holds a tree of nested data when using repeaters or complex fields.
	 *
	 * @since 3.0
	 * @var mixed
	 */
	protected $tree = array();

	/**
	 * Holds a tree of nested layout field iterators.
	 *
	 * @since 3.0
	 * @var mixed[]
	 */
	protected $layout_tree = array();

	/**
	 * Holds a hash for the last loaded level when using repeatable fields.
	 *
	 * @since 3.0
	 * @var string
	 */
	protected $last_hash;

	/**
	 * Holds a hash for the last loaded level when using the layout field fields.
	 *
	 * @since 3.0
	 * @var string
	 */
	protected $last_layout_hash;

	/**
	 * Creates an instance of the data API.
	 * To avoid conflicts with nested loop, there must be a single instance of this class.
	 *
	 * @since 3.0
	 *
	 * @return Data_API
	 */
	public static function instance() {
		static $instance;

		if( is_null( $instance ) ) {
			$instance = new self();
		}

		return $instance;
	}

	/**
	 * Prevents external instances of the class.
	 *
	 * @since 3.0
	 */
	private function __construct() {}

	/**
	 * Retrieves a value based on a source (name + type + ID).
	 *
	 * @param mixed[] $source  The source that's being worked with.
	 * @param bool    $process Indicates if the value should be processed by the responsible field.
	 * @return mixed
	 */
	 protected function get( $source, $process = false ) {
 		$value         = false;
 		$containers    = array();

 		/**
 		 * Find the containers, which are applicable to the location of the source.
 		 *
 		 * This will be done based on the containers' location and the datastore generated by it.
 		 */
 		foreach( Container::get_registered() as $container ) {
 			$works = false;

 			foreach( $container->get_locations() as $location ) {
 				if( ! $object = $location->works_with( $source ) ) {
 					continue;
 				}

 				$datastore = $location->get_datastore( $object );
 				$works     = true;
 				break;
 			}

 			if( $works ) {
 				$containers[] = compact( 'container', 'datastore' );
 			}
 		}

 		/**
 		 * Go through each container and let it handle the value if possible.
 		 *
 		 * This will check if there is a field that can process the needed key, even if it's
 		 * not real (ex. link vs link_target, which are all handled by the same field).
 		 */
 		foreach( $containers as $combo ) {
			$container = $combo[ 'container' ];
			$datastore = $combo[ 'datastore' ];

 			if( $name = $container->can_handle( $source ) ) {
				$value = $datastore->get( $name );
				$value = $container->handle( $value, $source );

 				if( $process ) {
 					$value = $container->process( $value, $source );
 				}

 				return $value;
 			}
 		}

		/**
		 * If the function has not returned data yet, it means that there is no container/field
		 * that can actually and properly parse the value.
		 *
		 * Therefore, we are reverting back to simple datastore mode, so that even a value that
		 * is not currently associated with a field from the plugin can be retrieved.
		 */
		foreach( $containers as $combo ) {
			$datastore = $combo[ 'datastore' ];

			if( $value = $datastore->get( $source->name ) ) {
				return $value;
			}
		}

 		# Nothing found.
 		return false;
 	}

	/**
	 * Updates a value.
	 *
	 * @since 3.0
	 *
	 * @param Ultimate_Fields\Helper\Data_Source $source The source of the value that needs to be updated.
	 * @param mixed                  $value  The value to update.
	 * @return bool                  An indicator if the value has been successfully updated.
	 */
	public function update( $source, $value ) {
		$containers = array();

		# Find the value and contaienrs, which might work with it
		foreach( Container::get_registered() as $container ) {
			$works = false;

			foreach( $container->get_locations() as $location ) {
				if( ! $object = $location->works_with( $source ) ) {
					continue;
				}

				$datastore = $location->get_datastore( $object );
				$works     = true;

				break;
			}

			if( $works ) {
				$containers[] = $container;
			}
		}

		# Check if a container can actually process the value
		foreach( $containers as $container ) {
			if( $container->can_handle( $source ) ) {
				$container->set_datastore( $datastore );
				return $container->update_value( $source->name, $value );
			}
		}

		return false;
	}

	/**
	 * Generates a new data source.
	 *
	 * @since 3.0
	 *
	 * @param mixed  $type The type/location of a vaue, ex. post_3, user_5 and etc.
	 * @param string $name The name of a field, whose data is needed.
	 * @return Data_Source
	 */
	protected function parse_source( $type, $name ) {
		return call_user_func_array(
			array( Data_Source::class, 'parse' ),
			func_get_args()
		);
	}

	/**
	 * Returns a raw value.
	 *
	 * This value will be handled by the coresponding field, but not processed.
	 * For example, an image field would return the image ID when used, instead of an image.
	 *
	 * @since 3.0
	 *
	 * @param  string $name The name of the field, which the value belongs to.
	 * @param  mixed  $type The type of the object, which the value belongs to.
	 * @return mixed
	 */
	public function get_value( $name, $type = '' ) {
		$source = $this->parse_source( $type, $name );
		return $this->get( $source );
	}

	/**
	 * Returns a processed value.
	 *
	 * This value will be handled and processed by the coresponding field.
	 * For example, an image field would return it's proper output value, instead of a simple ID.
	 *
	 * @since 3.0
	 *
	 * @param  string $name The name of the field, which the value belongs to.
	 * @param  mixed  $type The type of the object, which the value belongs to.
	 * @return mixed
	 */
	public function get_the_value( $name, $type = '' ) {
		$source = $this->parse_source( $type, $name );
		$value  = $this->get( $source, true );

		/**
		 * Allows the value of `get_the_value` or `the_value` to be modified.
		 *
		 * @since 3.0
		 *
		 * @param mixed       $value  The value that has been loaded.
		 * @param string      $name   The name of the field whose value is displayed.
		 * @param Data_Source $source The context of the value (name, location type, etc.).
		 * @return mixed
		 */
		$value = apply_filters( 'uf.api.the_value', $value, $name, $type );

		return $value;
	}

	/**
	 * Displays the value of a field.
	 *
	 * @since 3.0
	 *
	 * @param string $name The name of the field.
	 * @param mixed  $type The type of the object, which the value belongs to.
	 */
	public function the_value( $name, $type = '' ) {
		echo $this->get_the_value( $name, $type );
	}

	/**
	 * Updates a value.
	 *
	 * @since 3.0
	 *
	 * @param string $name The name of the field whose value should be updated.
	 * @param mixed  $type The type of the object, which the value belongs to.
	 * @return bool        An indicator whether the value was actually updated.
	 */
	public function update_value( $name, $value, $type = '' ) {
		$source = $this->parse_source( $type, $name );
		return $this->update( $source, $value );
	}

	/**
	 * Checks if there are any groups left to iterate.
	 *
	 * @since 3.0
	 *
	 * @param string $name The name of the needed field.
	 * @param mixed  $type The needed context for the value.
	 * @return bool
	 */
	public function have_groups( $name, $type = null ) {
		$source = $this->parse_source( $type, $name );
		$hash   = $source->hash();

		# Enter the next-level of sub-groups if needed and possible
		if( $hash != $this->last_hash && is_null( $type ) && $sub = $this->get_sub_value( $name ) ) {
			# Ensure that the nested thing is an iterator
			if( is_a( $sub, Groups_Iterator::class ) ) {
				$iterator = $sub;

				$this->tree[ $hash ] = $iterator->loop_mode();
				$this->last_hash = $hash;
				return true;
			}
		}

		# If the requested thing is already in the tree, work with it
		if( isset( $this->tree[ $hash ] ) ) {
			if( $this->tree[ $hash ]->valid() ) {
				return true;
			} else {
				# Pop the level
				$this->tree[ $hash ]->rewind();
				unset( $this->tree[ $hash ] );
				$this->last_hash = false;

				# Restore the last hash
				foreach( array_reverse( $this->tree ) as $hash => $iterator ) {
					$this->last_hash = $hash;
					break;
				}

				return false;
			}
		}

		# Check for a new level
		$iterator = $this->get( $source );

		if( ! $iterator || ! ( is_a( $iterator, Groups_Iterator::class ) || is_a( $iterator, Complex_Values::class ) ) ) {
			return false;
		}

		$this->tree[ $hash ] = $iterator->loop_mode();
		$this->last_hash = $hash;
		return $iterator->valid();
	}

	/**
	 * Checks if there are any groups left to iterate.
	 *
	 * @since 3.0
	 *
	 * @param string $name The name of the needed field.
	 * @param mixed  $type The needed context for the value.
	 * @return bool
	 */
	public function have_rows( $name, $type = null ) {
		$source = $this->parse_source( $type, $name );
		$hash   = $source->hash();

		# If there is an existing loop, use it.
		if( isset( $this->layout_tree[ $hash ] ) ) {
			if( $this->layout_tree[ $hash ]->valid() ) {
				return true;
			} else {
				# Pop the level
				$this->layout_tree[ $hash ]->rewind();
				unset( $this->layout_tree[ $hash ] );

				# Restore the last hash
				$this->last_layout_hash = false;
				foreach( array_reverse( $this->layout_tree ) as $hash => $iterator ) {
					$this->last_layout_hash = $hash;
					break;
				}

				return false;
			}
		}

		# Check for a new level
		$iterator = $this->get( $source );
		if( ! $iterator || ! is_a( $iterator, Layout_Rows_Iterator::class ) ) {
			return false;
		}

		$this->layout_tree[ $hash ] = $iterator->loop_mode();
		$this->last_layout_hash = $hash;
		return true;
	}

	/**
	 * Iterates over a Groups_Iterator.
	 *
	 * @since 3.0
	 */
	public function the_group() {
		if( ! $this->last_hash ) {
			return;
		}

		$iterator = $this->tree[ $this->last_hash ];
		$iterator->next();
	}

	/**
	 * Iterates ofver a Layout_Rows_Iterator.
	 *
	 * @since 3.0
	 */
	public function the_row() {
		if( ! $this->last_layout_hash ) {
			return;
		}

		$iterator = $this->layout_tree[ $this->last_layout_hash ];
		$iterator->next();

		# Get the group iterator from the row and put it in the tree
		$group = $iterator->current()->loop_mode();
		$this->tree[ $this->last_layout_hash ] = $group;
		$this->last_hash = $this->last_layout_hash;
	}

	/**
	 * Returns the type of the currently looped group.
	 *
	 * @since 3.0
	 *
	 * @return string
	 */
	public function get_group_type() {
		if( ! $this->last_hash )
			return false;

		if( ! isset( $this->tree[ $this->last_hash ] ) )
			return false;

		$group = $this->tree[ $this->last_hash ]->current();

		return $group[ '__type' ];
	}

	/**
	 * When working with the layout fields, this will return the width of the current group.
	 *
	 * @since 3.0
	 *
	 * @return bool|int Either a column count or false.
	 */
	public function get_group_width() {
		if( ! $this->last_hash )
			return false;

		if( ! isset( $this->tree[ $this->last_hash ] ) )
			return false;

		$group = $this->tree[ $this->last_hash ]->current();

		if( ! $group || ! is_a( $group, Layout_Group_Values::class ) ) {
			return false;
		}

		return $group[ '__width' ];
	}

	/**
	 * When working with the layout fields, this will display the width of the current group.
	 *
	 * @since 3.0
	 */
	public function the_group_width() {
		echo $this->get_group_width();
	}

	/**
	 * Returns a sub-value from a repeater group.
	 *
	 * @since 3.0
	 *
	 * @param string $name The name of the needed value.
	 * @return mixed
	 */
	public function get_sub_value( $name ) {
		if( empty( $this->tree ) ) {
			return false;
		}

		foreach( array_reverse( $this->tree ) as $hash => $iterator ) {
			$group = $iterator->current();

			if( isset( $group[ $name ] ) ) {
				return $group[ $name ];
			}
		}

		return false;
	}

	/**
	 * Returns a processed value from a repeater/layout group.
	 *
	 * @since 3.0
	 *
	 * @param string $name The name of the value.
	 * @return mixed
	 */
	public function get_the_sub_value( $name ) {
		if( empty( $this->tree ) ) {
			return false;
		}

		foreach( array_reverse( $this->tree ) as $hash => $iterator ) {
			if( ! $iterator->ready() ) {
				continue;
			}

			$group = $iterator->current();

			if( $key = $group->can_handle( $name ) ) {
				$source = Data_Source::parse( null, $name );
				return $group->get_processed( $key, $source );
			}
		}

		return false;
	}

	/**
	 * Outputs a value from the currently iterated group.
	 *
	 * @since 3.0
	 *
	 * @param string $name The name of the sub-field.
	 * @return mixed[]
	 */
	public function the_sub_value( $name ) {
		echo $this->get_the_sub_value( $name );
	}

	/**
	 * Updates a sub-value in a repeater group.
	 *
	 * @since 3.0
	 *
	 * @param string $name  The name of the needed value.
	 * @param mixed  $value The value to set.
	 * @return bool
	 */
	public function update_sub_value( $name, $value ) {
		if( empty( $this->tree ) ) {
			return false;
		}

		foreach( array_reverse( $this->tree ) as $hash => $iterator ) {
			if( ! $iterator->ready() ) {
				continue;
			}

			$group = $iterator->current();

			if( isset( $group[ $name ] ) ) {
				$group[ $name ] = $value;
				return true;
			}
		}

		return false;
	}

	/**
	 * Saves the sub-values for a field after they have been updated.
	 *
	 * @since 3.0
	 *
	 * @param string $name The name of the top-level field to update.
	 * @param mixed  $type The object that the field belongs to.
	 * @return bool An indicator of success.
	 */
	public function save_sub_values( $name, $type = '' ) {
		$source = $this->parse_source( $type, $name );
		$hash   = $source->hash();

		# Check for layouts
		if( isset( $this->layout_tree[ $hash ] ) ) {
			return $this->layout_tree[ $hash ]->save();
		}

		# Check for repeaters
		if( isset( $this->tree[ $hash ] ) ) {
			return $this->tree[ $hash ]->save();
		}
	}
}
